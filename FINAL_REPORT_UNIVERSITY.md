# ПРОЕКТНАЯ РАБОТА

# РАЗРАБОТКА МИКРОСЕРВИСНОЙ АРХИТЕКТУРЫ СИСТЕМЫ УПРАВЛЕНИЯ АВТОСАЛОНОМ

**Студент:** [Ваше ФИО]  
**Группа:** [Ваша группа]  
**Специальность:** [Ваша специальность]  
**Преподаватель:** [ФИО преподавателя]  

**Санкт-Петербург**  
2025

---

# АННОТАЦИЯ

В данной проектной работе рассматривается разработка полнофункциональной микросервисной архитектуры для системы управления автосалоном. Проект реализован с использованием современных технологий: Python 3.11, FastAPI, PostgreSQL, RabbitMQ и Docker.

Основное внимание уделено принципам микросервисной архитектуры, таким как Database-per-Service паттерн, API Gateway, JWT аутентификация и Event-Driven коммуникация. Система включает пять независимых сервисов: аутентификации, платежей, кредитования, страхования и API Gateway.

Проект демонстрирует практическое применение архитектурных паттернов, обеспечивающих масштабируемость, отказоустойчивость и независимое развертывание компонентов системы.

**Ключевые слова:** микросервисы, FastAPI, PostgreSQL, Docker, JWT, API Gateway, Database-per-Service.

---

# СОДЕРЖАНИЕ

1. [ВВЕДЕНИЕ](#введение)
   1.1. Актуальность темы
   1.2. Цель и задачи работы
   1.3. Структура работы

2. [ТЕОРЕТИЧЕСКИЕ ОСНОВЫ](#теоретические-основы)
   2.1. Микросервисная архитектура
   2.2. Database-per-Service паттерн
   2.3. API Gateway паттерн
   2.4. JWT аутентификация
   2.5. Event-Driven архитектура
   2.6. Технологический стек

3. [ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ](#практическая-реализация)
   3.1. Архитектура системы
   3.2. Структура проекта
   3.3. Сервис аутентификации
   3.4. Сервис платежей
   3.5. Сервис кредитования
   3.6. Сервис страхования
   3.7. API Gateway
   3.8. Интеграция и коммуникация сервисов

4. [ТЕСТИРОВАНИЕ И ИНТЕГРАЦИЯ](#тестирование-и-интеграция)
   4.1. Модульное тестирование
   4.2. Интеграционное тестирование
   4.3. Docker контейнеризация
   4.4. Развертывание системы

5. [ЗАКЛЮЧЕНИЕ](#заключение)

6. [СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ](#список-использованной-литературы)

7. [ПРИЛОЖЕНИЯ](#приложения)
   Приложение А. Исходный код сервиса аутентификации
   Приложение Б. Исходный код API Gateway
   Приложение В. Исходный код сервиса платежей
   Приложение Г. Исходный код сервиса кредитования
   Приложение Д. Исходный код сервиса страхования
   Приложение Е. Конфигурационные файлы

---

# 1. ВВЕДЕНИЕ

## 1.1. Актуальность темы

В современном мире информационных технологий микросервисная архитектура становится стандартом для разработки крупных и масштабируемых приложений. Традиционная монолитная архитектура часто оказывается недостаточно гибкой для быстрого развития и поддержки сложных систем.

Микросервисная архитектура позволяет:
- Независимо масштабировать отдельные компоненты системы
- Использовать различные технологии для разных задач
- Обеспечивать высокую отказоустойчивость
- Ускорить процесс разработки и развертывания

Данная работа посвящена практическому применению принципов микросервисной архитектуры на примере системы управления автосалоном, что является актуальной задачей для предприятий автомобильной отрасли.

## 1.2. Цель и задачи работы

**Цель работы:** разработать полнофункциональную микросервисную систему управления автосалоном, демонстрирующую современные подходы к проектированию и реализации распределенных приложений.

**Основные задачи:**
1. Изучить теоретические основы микросервисной архитектуры
2. Спроектировать архитектуру системы с применением паттернов Database-per-Service и API Gateway
3. Реализовать пять независимых микросервисов на Python с использованием FastAPI
4. Организовать безопасную аутентификацию и авторизацию пользователей
5. Настроить асинхронное взаимодействие между сервисами через брокер сообщений
6. Обеспечить контейнеризацию и оркестрацию с помощью Docker и Docker Compose
7. Протестировать систему и подготовить документацию

## 1.3. Структура работы

Работа состоит из введения, четырех основных глав, заключения, списка литературы и приложений. Первая глава посвящена теоретическим основам микросервисной архитектуры. Вторая глава описывает практическую реализацию системы. Третья глава содержит анализ тестирования и интеграции. В приложениях приведен полный исходный код проекта.

---

# 2. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ

## 2.1. Микросервисная архитектура

Микросервисная архитектура (Microservices Architecture) - это подход к разработке программного обеспечения, при котором приложение строится как набор небольших сервисов, каждый из которых работает в своем собственном процессе и взаимодействует с другими через четко определенные API.

### Преимущества микросервисной архитектуры:

1. **Независимое развертывание** - каждый сервис может быть обновлен и развернут независимо от других
2. **Технологическая свобода** - разные сервисы могут использовать разные технологии
3. **Масштабируемость** - сервисы можно масштабировать индивидуально
4. **Отказоустойчивость** - сбой в одном сервисе не влияет на всю систему
5. **Упрощенное тестирование** - каждый сервис можно тестировать изолированно

### Недостатки микросервисной архитектуры:

1. **Сложность управления** - требуется координация между множеством сервисов
2. **Распределенные транзакции** - сложность обеспечения консистентности данных
3. **Мониторинг и отладка** - сложнее отслеживать взаимодействие сервисов
4. **Задержки в сети** - коммуникация между сервисами происходит по сети

## 2.2. Database-per-Service паттерн

Database-per-Service - это паттерн, при котором каждый микросервис имеет свою собственную базу данных. Это обеспечивает полную изоляцию данных и позволяет сервисам развиваться независимо.

### Преимущества Database-per-Service:

1. **Изоляция данных** - сервисы не могут случайно повлиять на данные друг друга
2. **Независимое масштабирование** - каждый сервис может выбрать оптимальную стратегию масштабирования БД
3. **Технологическая свобода** - разные сервисы могут использовать разные СУБД
4. **Упрощенная эволюция схемы** - изменения в схеме одного сервиса не влияют на другие
5. **Улучшенная отказоустойчивость** - проблемы в одной БД не затрагивают другие сервисы

### Взаимодействие между сервисами:

Поскольку каждый сервис имеет свою базу данных, взаимодействие происходит через:
- **Синхронные вызовы** (REST/gRPC) для непосредственных запросов
- **Асинхронные события** через брокер сообщений для слабосвязанного взаимодействия

## 2.3. API Gateway паттерн

API Gateway - это единая точка входа для всех клиентских запросов к микросервисной системе. Этот паттерн решает следующие проблемы:

1. **Маршрутизация запросов** - перенаправление запросов к соответствующим сервисам
2. **Аутентификация и авторизация** - централизованная проверка доступа
3. **Агрегация ответов** - сбор данных из нескольких сервисов в один ответ
4. **Балансировка нагрузки** - распределение запросов между экземплярами сервисов
5. **Кэширование** - хранение часто запрашиваемых данных
6. **Ограничение скорости** (Rate Limiting) - защита от перегрузок

## 2.4. JWT аутентификация

JSON Web Token (JWT) - это открытый стандарт для создания токенов доступа, основанный на JSON. JWT используется для безопасной передачи информации между сторонами в виде JSON-объекта.

### Структура JWT:

JWT состоит из трех частей, разделенных точками:
1. **Header** - содержит тип токена и алгоритм подписи
2. **Payload** - содержит claims (утверждения) о пользователе
3. **Signature** - цифровая подпись для проверки целостности

### Преимущества JWT:

1. **Самодостаточность** - токен содержит всю необходимую информацию
2. **Масштабируемость** - не требует хранения сессий на сервере
3. **Кросс-доменность** - работает в разных доменах
4. **Безопасность** - цифровая подпись предотвращает подделку

### Access и Refresh токены:

В данной системе используются два типа токенов:
- **Access токен** - короткоживущий токен для доступа к защищенным ресурсам
- **Refresh токен** - долгоживущий токен для получения новых access токенов

## 2.5. Event-Driven архитектура

Event-Driven Architecture (EDA) - это парадигма проектирования, где поток программы определяется событиями. В микросервисной архитектуре события используются для асинхронного взаимодействия между сервисами.

### Компоненты Event-Driven архитектуры:

1. **Производители событий (Event Producers)** - сервисы, генерирующие события
2. **Брокер сообщений (Message Broker)** - промежуточное ПО для маршрутизации сообщений
3. **Потребители событий (Event Consumers)** - сервисы, реагирующие на события

### Преимущества Event-Driven подхода:

1. **Слабая связанность** - сервисы не знают друг о друге напрямую
2. **Асинхронность** - сервисы могут работать независимо от скорости друг друга
3. **Масштабируемость** - легко добавлять новых потребителей событий
4. **Отказоустойчивость** - система продолжает работать при недоступности отдельных компонентов

## 2.6. Технологический стек

Для реализации проекта выбран следующий технологический стек:

### Backend:
- **Python 3.11** - основной язык программирования
- **FastAPI** - современный фреймворк для создания REST API
- **SQLAlchemy** - ORM для работы с базами данных
- **Pydantic** - валидация данных и сериализация

### Базы данных:
- **PostgreSQL** - реляционная СУБД для всех сервисов
- **Database-per-Service** - каждая база данных изолирована

### Инфраструктура:
- **Docker** - контейнеризация приложений
- **Docker Compose** - оркестрация контейнеров
- **RabbitMQ** - брокер сообщений для Event-Driven коммуникации

### Безопасность:
- **JWT** - токены для аутентификации
- **OAuth2** - протокол авторизации
- **bcrypt** - хэширование паролей

---

# 3. ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ

## 3.1. Архитектура системы

Система управления автосалоном состоит из пяти микросервисов, каждый из которых отвечает за определенную бизнес-область:

### Сервисы системы:

1. **API Gateway** (порт 8000)
   - Единая точка входа для клиентских запросов
   - Маршрутизация и аутентификация
   - Агрегация данных из нескольких сервисов

2. **Auth Service** (порт 8001, база auth_db:54321)
   - Управление пользователями
   - Аутентификация и авторизация
   - Выдача JWT токенов

3. **Payment Service** (порт 8002, база payment_db:54322)
   - Обработка платежей
   - Управление транзакциями
   - Интеграция с платежными системами

4. **Financing Service** (порт 8003, база financing_db:54323)
   - Кредитные заявки
   - Расчет графиков платежей
   - Оценка кредитоспособности

5. **Insurance Service** (порт 8004, база insurance_db:54324)
   - Страховые полисы
   - Расчет стоимости страхования
   - Управление страховыми случаями

### Взаимодействие сервисов:

- **Синхронное** - через REST API для непосредственных запросов
- **Асинхронное** - через RabbitMQ для событий (payment.created, financing.approved, insurance.purchased)

## 3.2. Структура проекта

```
autosalon-microservices/
├── docker-compose.yml          # Конфигурация Docker Compose
├── requirements.txt            # Python зависимости
├── Dockerfile                  # Docker образ для сервисов
├── shared/                     # Общие модули
│   ├── models.py              # Общие модели данных
│   ├── auth.py                # Утилиты аутентификации
│   ├── database.py            # Настройки базы данных
│   └── messaging.py           # Работа с брокером сообщений
├── auth-service/              # Сервис аутентификации
├── api-gateway-service/       # API Gateway
├── payment-service/           # Сервис платежей
├── financing-service/         # Сервис кредитования
└── insurance-service/         # Сервис страхования
```

## 3.3. Сервис аутентификации

Сервис аутентификации предоставляет следующие функции:

### Основные endpoint'ы:

- `POST /register` - регистрация нового пользователя
- `POST /token` - получение access и refresh токенов
- `POST /refresh` - обновление access токена
- `GET /me` - получение информации о текущем пользователе
- `GET /users/{user_id}` - получение информации о пользователе (admin/manager)
- `PUT /users/{user_id}` - обновление информации о пользователе

### Ролевая модель:

Система поддерживает три роли пользователей:
- **client** - обычный клиент автосалона
- **manager** - менеджер автосалона
- **admin** - администратор системы

### Модель пользователя:

```python
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    full_name = Column(String)
    phone = Column(String)
    hashed_password = Column(String)
    role = Column(Enum(UserRole), default=UserRole.CLIENT)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

## 3.4. Сервис платежей

Сервис платежей отвечает за обработку финансовых транзакций автосалона.

### Основные функции:

- Создание платежей
- Обработка различных методов оплаты (карта, наличные, кредит)
- Отслеживание статуса платежей
- Генерация отчетов по платежам

### Модель платежа:

```python
class Payment(Base):
    __tablename__ = "payments"

    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, index=True)
    user_id = Column(Integer, index=True)
    amount = Column(Float)
    method = Column(String)  # card, cash, credit
    status = Column(String, default="pending")  # pending, completed, failed
    description = Column(String)
    transaction_id = Column(String, unique=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

## 3.5. Сервис кредитования

Сервис кредитования предоставляет функциональность для работы с кредитными заявками и расчетом графиков платежей.

### Основные функции:

- Создание кредитных заявок
- Расчет ежемесячных платежей
- Оценка кредитоспособности
- Управление статусом заявок

### Алгоритм расчета кредитного платежа:

Для расчета аннуитетного платежа используется формула:

```
P = PV × [r × (1 + r)^n] / [(1 + r)^n - 1]
```

Где:
- P - ежемесячный платеж
- PV - сумма кредита
- r - месячная процентная ставка
- n - количество месяцев

## 3.6. Сервис страхования

Сервис страхования управляет страховыми полисами и расчетом стоимости страхования.

### Типы страхования:

- **ОСАГО** - обязательное страхование автогражданской ответственности
- **КАСКО** - добровольное страхование транспортного средства
- **Страхование жизни** - страхование водителя и пассажиров

### Факторы, влияющие на стоимость:

- Марка и модель автомобиля
- Год выпуска
- Пробег
- Регион использования
- Возраст и стаж водителя
- Наличие аварий в истории

## 3.7. API Gateway

API Gateway служит единой точкой входа для всех клиентских запросов и предоставляет следующие функции:

### Маршрутизация:

```python
@app.api_route("/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH"])
async def gateway_route(request: Request, path: str):
    # Логика маршрутизации запросов к соответствующим сервисам
    pass
```

### Аутентификация:

```python
async def authenticate_request(request: Request) -> Optional[dict]:
    # Извлечение и верификация JWT токена
    # Проверка прав доступа
    pass
```

## 3.8. Интеграция и коммуникация сервисов

### Синхронная коммуникация:

Сервисы взаимодействуют через REST API для непосредственных запросов. Например, API Gateway может запрашивать информацию о пользователе из Auth Service:

```python
async def get_user_info(user_id: int) -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(f"http://auth-service:8001/users/{user_id}")
        return response.json()
```

### Асинхронная коммуникация:

Для слабосвязанного взаимодействия используется RabbitMQ. Примеры событий:

- `payment.created` - создан новый платеж
- `financing.approved` - одобрена кредитная заявка
- `insurance.purchased` - приобретен страховой полис

### Обработка событий:

```python
async def handle_payment_created(event_data: dict):
    # Обновление статуса заказа
    # Отправка уведомлений
    # Логирование транзакции
    pass
```

---

# 4. ТЕСТИРОВАНИЕ И ИНТЕГРАЦИЯ

## 4.1. Модульное тестирование

Для каждого сервиса написаны модульные тесты, проверяющие корректность работы отдельных компонентов.

### Пример теста для сервиса аутентификации:

```python
def test_create_user():
    # Arrange
    user_data = UserCreate(
        email="test@example.com",
        full_name="Test User",
        password="password123",
        phone="+7-999-123-45-67",
        role=UserRole.CLIENT
    )

    # Act
    created_user = UserCRUD.create_user(db, user_data)

    # Assert
    assert created_user.email == user_data.email
    assert created_user.full_name == user_data.full_name
    assert created_user.role == user_data.role
```

## 4.2. Интеграционное тестирование

Интеграционные тесты проверяют взаимодействие между сервисами и корректность бизнес-логики.

### Сценарий полного цикла:

1. Регистрация пользователя
2. Аутентификация и получение токена
3. Создание заказа на автомобиль
4. Оформление кредита
5. Оплата и страхование
6. Проверка статуса заказа

## 4.3. Docker контейнеризация

Все сервисы контейнеризованы с помощью Docker для обеспечения консистентности окружения.

### Dockerfile для сервисов:

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Docker Compose конфигурация:

```yaml
version: '3.8'
services:
  auth-service:
    build: ./auth-service
    ports:
      - "8001:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@auth-db:5432/auth_db
    depends_on:
      - auth-db

  auth-db:
    image: postgres:15
    environment:
      - POSTGRES_DB=auth_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    ports:
      - "54321:5432"
```

## 4.4. Развертывание системы

### Быстрый запуск:

```bash
# Клонирование репозитория
git clone <repository-url>
cd autosalon-microservices

# Запуск всех сервисов
docker-compose up --build
```

### Проверка работоспособности:

```bash
# Health check всех сервисов
curl http://localhost:8000/health
curl http://localhost:8001/health
curl http://localhost:8002/health
curl http://localhost:8003/health
curl http://localhost:8004/health
```

---

# 5. ЗАКЛЮЧЕНИЕ

В результате выполнения проектной работы была разработана полнофункциональная микросервисная система управления автосалоном, демонстрирующая современные подходы к проектированию распределенных приложений.

### Достигнутые результаты:

1. **Спроектирована и реализована** микросервисная архитектура с пятью независимыми сервисами
2. **Применен Database-per-Service паттерн** - каждый сервис имеет изолированную базу данных
3. **Реализован API Gateway** - единая точка входа с аутентификацией и маршрутизацией
4. **Организована безопасная аутентификация** с использованием JWT токенов и ролевой моделью
5. **Настроено асинхронное взаимодействие** между сервисами через RabbitMQ
6. **Обеспечена контейнеризация** и оркестрация с помощью Docker и Docker Compose

### Архитектурные преимущества реализованной системы:

- **Масштабируемость** - каждый сервис можно масштабировать независимо
- **Отказоустойчивость** - сбой в одном сервисе не влияет на всю систему
- **Технологическая гибкость** - возможность использования разных технологий
- **Упрощенное развертывание** - контейнеризация обеспечивает консистентность окружения

### Перспективы развития:

Для дальнейшего развития системы рекомендуется:

1. Добавить оставшиеся сервисы (продажи, склад, обслуживание клиентов)
2. Реализовать Saga паттерн для распределенных транзакций
3. Добавить мониторинг и метрики (Prometheus + Grafana)
4. Внедрить кэширование с Redis
5. Разработать фронтенд приложение
6. Добавить API rate limiting и circuit breaker

Проект демонстрирует практическое применение принципов микросервисной архитектуры и может служить основой для создания более сложных распределенных систем.

---

# 6. СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ

1. Newman S. Building Microservices. - O'Reilly Media, 2015. - 280 p.
2. Richardson C. Microservices Patterns. - Manning Publications, 2018. - 520 p.
3. Wolff E. Microservices: Flexible Software Architecture. - Addison-Wesley, 2016. - 312 p.
4. FastAPI Documentation: https://fastapi.tiangolo.com/
5. SQLAlchemy Documentation: https://sqlalchemy.org/
6. Docker Documentation: https://docs.docker.com/
7. RabbitMQ Documentation: https://www.rabbitmq.com/documentation.html
8. JWT RFC 7519: https://tools.ietf.org/html/rfc7519

---

# 7. ПРИЛОЖЕНИЯ